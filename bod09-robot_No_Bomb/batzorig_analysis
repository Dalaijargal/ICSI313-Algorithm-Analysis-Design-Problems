1	 Dp хүснэгт үүсгэгч бүх элементийг тэглэнэ.
// Суурь элементээ ашиглан зөвхөн дээрээс ирэх боломжтой элементүүдийг тооцоолно. Өөрөөр Хэлбэл суурь баганыг тооцоолно.
2	 Dp[1][n]=a[1][n]
//Суурь элементээ ашиглан зөвхөн хойноос ирэх боломжтой элементүүдийг тооцоолно. Өөрөөр хэлбэл Суурь мөрийг тооцоолно.
3	 n Зүгээр баганын 2-ос. N хүртэлх мөрөөр гүйж. -1 тээ үл тэнцэх байвал.  Dp[i][n]=a[i][n]+Dp[i-1][n]
-1 Тийм тэнцүү байвал. эсвэл өмнөх элемент нь -1 тээ тэнцүү байвал
 Dp!i][n]=-1 Ийг Онон.
//Тооцоолсон суурь багана болон мөрөө ашиглан хамгийн сайн тохиолдлыг бодож олно.
4	 1 Дүгээр мөрний n-1 ээс 1 Дүгээр элемент  хүртэл гүйж. -1 тээ үл тэнцэж байвал    Dp[1][i]=a[1][i]+Do[1][i-1] 
-1 тээ тэнцүү байвал эсвэл өмнөх элемент нь -1 тээ тэнцүү байвал Dp[1][i]=-1 ийг онооно
// Үүсгэсэн суурь багана болон суурь мөрөө ашиглан тухайн цэгүүд дээр очих хамгийн сайн  Боломжийг буюу тухайн цэг дээр очихдоо цуглуулах боломжтой. Хамгийн их зоосыг олно.
5	 2-ос. n хүртэлх мөрүүдийн n-1 ээс нэг хүртэлх багануудаар гүйж.-1 тээ үл тэнцэж байвал    Dp[1][i]=a[1][i]+max(Dp[i-1][j].Dp[i][j+1])
-1 тээ тэнцүү байвал Dp[i][j]=-1 ийг онооно
6	 DP[n][1] ийг хэвэл 
хугацаа
дэд бодлогыг хугацааг үржих нь дэд бодлогыг тоо
O(1*n^2)=O(n^2)
