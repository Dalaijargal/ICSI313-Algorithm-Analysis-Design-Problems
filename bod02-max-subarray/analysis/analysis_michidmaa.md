## _MAX SUBARRAY_

# Бодлого
Эерэг сөрөг бүхэл тоо агуулах А хүснэгт өгөгдөв. Энэ хүснэгтээс хоосон биш, тасралтгүй, гишүүдийнх нь нийлбэр хамгийн их байх дэд хэсгийг ол.

# Жишээ  
Дараах хүснэгт өгөгдөхөд нийлбэр нь хамгийн их байх тасралтгүй дэд хэсгийн нийлбэр A[8..11] = 18 + 20 – 7 + 12 = 43 байна. Гишүүдийнх нь нийлбэр 43-аас их байх өөр дэд хэсэг олдохгүй.

![N|Solid](https://github.com/Nyamdavaa2k01/ICSI313-Algorithm-Analysis-Design-Problems/blob/main/bod02-max-subarray/analysis/maxsubarray1.png?raw=true)

Хэрэв хүснэгтийн утгууд бүгд сөрөг биш тоонууд байсан бол max-subarray олдохгүй.

# Brute-Force O(n^2)
А хүснэгтийн бүх боломжит интервалыг авч үзэн тус бүрийнх нь нийлбэрийг олох замаар maximum subarray-г ольё. Энэ нь интервалын эхний болон сүүлчийн элементийн хослолын бүх боломжийг авч үзнэ гэсэн үг ба нийт n элементээс 2 элементийг сонгох боломж буюу (n 2) =  O(n^2). 
Интервал бүрийн хувьд нийлбэрийг тооцох хугацаа тогтмол.
Иймд энэ санаагаар O(n^2) хугацаанд бодогдоно.

# Хуваан эзлэх зарчим
**1. Хуваах**

Бидний олох max-subarray нь A[low..high] байг. Хуваан эзлэх зарчмаар энэ интервалыг аль болох тэнцүү хэмжээтэй хоёр дэд интервалд хуваан авч үзье. Голын элементийг mid гэж нэрлэвэл A[low..mid], A[mid+1..high] гэсэн хоёр дэд хэсэгт хуваагдана. Тэгвэл бидний олох интервалын байрлал
- Зүүн A[low..mid] дэд хэсэгт бүхлээрээ багтах
- Баруун A[mid+1..high] дэд хэсэгт бүхлээрээ багтах
- Голын шугамыг заавал дайрсан байх

гэсэн гурван боломжийн аль нэг байх нь гарцаагүй. Энэ гурван хэсэг тус бүрт нь max-subarray-г бодож олоход хамгийн их нийлбэртэй интервал нь бодлогын хариу болно.

![N|Solid](https://github.com/Nyamdavaa2k01/ICSI313-Algorithm-Analysis-Design-Problems/blob/main/bod02-max-subarray/analysis/maxsubarray2.png?raw=true)

**2. Бодох**

A[low..mid], A[mid+1..high] дэд хэсгүүдийн max-subarray-г олох нь өөрөө манай эх бодлогын хувьд нэг жижиг тохиолдол нь болно. Иймд рекурсиваар олж болно.

**3. Нэгтгэх O(n)**

Харин гурав дахь боломж нь голын шугамыг заавал дайрсан байх гэсэн нөхцөл тавигдсан байгаа учраас эх бодлогын хувьд жижиг тохиолдол нь болж чадахгүй юм. Энэ үед дараах байдлаар шугаман хугацаанд олж болно.

![N|Solid](https://github.com/Nyamdavaa2k01/ICSI313-Algorithm-Analysis-Design-Problems/blob/main/bod02-max-subarray/analysis/maxsubarray3.png?raw=true)

Голын шугамыг дайрсан том интервалыг A[i..mid], A[mid+1..j] гэсэн хоёр хэсгээс тогтдог гэж үзье. Энэ хоёр хэсэг тус бүрийн max-subarray-г олоход тэдгээрийг нэгтгэсэн интервал нь гурав дахь дэд бодлогын хариу болно. Учир нь энд mid, mid+1 байрлал дахь элементүүдийг бэхэлж өгсөн тул энэ хоёр интервалыг нийлүүлэхэд заавал голын шугамыг дайрсан, нийлбэр нь хамгийн их байх нэг том интервал гарч ирнэ.

A[i..mid], A[mid+1..j] хэсгүүдийн max-subarray-г голын шугамаас эхлэн хоёр тийш дараалсан элементүүдийн нийлбэрийг бодох тул шугаман хугацаанд олдоно.

# Time complexity

Хуваан эзлэх зарчмаар зохиогдсон алгоритмын ажиллах хугацаа T(n) = aT(n/b) + f(n) байдаг.

Энэ бодлогын бодолтын хувьд:
-	Дэд бодлогын тоо a = 2
-	Дэд бодлогын хэмжээ n/2
-	Нэгтгэлийн хугацаа O(n)

тул Мастер теоремийн II нөхцлөөр нийт бодолтын хугацаа O(nlogn) болно. 
