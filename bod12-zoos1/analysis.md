# Бодлогын анализ

Бодлого 12. **Зоос 1.**

## Өгүүлбэр

Чамд C1 C2 C3 гэсэн зоосний хэмжээ болон n бүхэл тоо өгөгдөв тухайн төрлийн зоосноос хангалттай олон байгаа. Хамгийн бага зоос ашиглан хэрхэн задлах вэ, задлаж чадахгүй бол -1 буцаана.

## Оролт:

`n c1 c2 c3` зайгаар тусгаарлагдан өгөгдөнө.

## Гаралт:

Хэрвээ n-ийг задлах боломжтой бол нийт хэдэн боломжоор `задлах тоо`, хэрвээ
задлах боломжгүй бол `-1` хэвлэнэ.

## Хязгаарлалт:

`n<10^5` `m<100`

## Бодолт:

### Naive solution

Бид бүх боломжит 3-н тооны нийлбэрийг авж тухайн тоо гарах эсэхийг шалгаж болно.
Эсвэл тухайн тоонд багтах хамгийн том зоосыг хассаар дараагийн том зоосыг хасах
гэх байдлаар оролдож болно.

### O(n) solution

Бид `n` тоог гаргаж авахдаа, `c1` `c2` `c3` угсарч болох бүх утгуудыг авна. Ингэхдээ `c1`, `c2`, `c3`, `c1 + c2`, `c1 + c3` гэх мэтчилэн тухайн тоонуудын
задаргааг тооцож бодно.

Бид `dp` гэх нэртэй 1-ээс n хүртэлх тоог хадгалдаг хүснэгт үүсгэх бөгөөд үүнийг -1 дүүргэнэ. Хэрвээ бидний зоос байвал 1 тавих болно. Энэ хүснэгтийн index нь бидний зоосны нийлбэрээр гаргаж авах боломжтой тоог илэрхийлэх бөгөөд тухайн index-ийн утга нь хэдэн зоосоор угсрах боломжтойг хадгална.

`a = b + c1`, `a = d + c2` тохиолдолд бид хамгийн бага утгыг нь авах шаардлагатай тул `dp[a]` нь `dp[b] + 1`, `dp[d] + 1` хоёрын аль бага нь байна. Тэгвэл бид `b` болон `d` тоог угсарч чадах үгүйг мэдэх шаардлагатай.
Тиймээс бид 1 index-ээс нь төгсгөл рүү нь шахаж бодно.

1-ээс n хүртэлх бүх тоог үзэхдээ, тухайн тооноос зоосын утгыг хассан тоо нь хэрвээ -1 байвал бидний угсарч чадахгүй тоо байна. Харин өөр утга байвал гаргаж чадах тоо гэж үзээд аль бага зоос ашигласан тоон дээр 1-ийг нэмнэ.

Жишээ:
` 10 
 2 3 5`

> Init

| dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :----: |
|  -1   |  -1   |  -1   |  -1   |  -1   |  -1   |  -1   |  -1   |  -1   |   -1   |

> i = 2 (2 зоос байгаа тул dp[2] нь 1 болно)

| dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :----: |
|  -1   |   1   |  -1   |  -1   |  -1   |  -1   |  -1   |  -1   |  -1   |   -1   |

> i = 3 (3 зоос байгаа тул dp[3] нь 1 болно)

| dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :----: |
|  -1   |   1   |   1   |  -1   |  -1   |  -1   |  -1   |  -1   |  -1   |   -1   |

> i = 5 (5 зоос байгаа тул dp[5] нь 1 болно. 2 болон 3-аар гаргаж авах боломжтой ч хамгийн багаар явах ёстой тул 1 байна)

| dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :----: |
|  -1   |   1   |   1   |  -1   |   1   |  -1   |  -1   |  -1   |  -1   |   -1   |

> i = 7 (7 - 2 = 5 бөгөөд dp[5] нь 1 гэдэг утга агуулж байгаа тул dp[7] = dp[5] + 1 буюу 2)

| dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :----: |
|  -1   |   1   |   1   |  -1   |   1   |  -1   |   2   |  -1   |  -1   |   -1   |

> i = 8 (8 - 3 = 5 бөгөөд dp[5] нь 1 гэдэг утга агуулж байгаа тул dp[8] = dp[5] + 1 буюу 2)

| dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :----: |
|  -1   |   1   |   1   |  -1   |   1   |  -1   |   2   |   2   |  -1   |   -1   |

> i = 19 (10 - 5 = 5 бөгөөд dp[5] нь 1 гэдэг утга агуулж байгаа тул dp[10] = dp[5] + 1 буюу 2)

| dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :----: |
|  -1   |   1   |   1   |  -1   |   1   |  -1   |   2   |   2   |  -1   |   2    |

```cpp
typedef vector<int> InputType;

int solve(int n, InputType coins) {
  int dp[1000001];
  memset(dp, -1, sizeof dp);
  dp[0] = 0;
  for (int i = 1; i <= n; i++) {
    int minValue = INT_MAX;
    for (int j = 0; j < 3; j++) {
      if (i != coins[j]) {
        if (inBounds(i - coins[j], n) && dp[i - coins[j]] != -1) {
          minValue = min(dp[i - coins[j]] + 1, minValue);
        }
      }
      else {
        minValue = 1;
      }
      if (minValue != INT_MAX) dp[i] = minValue;
    }
  }
  return dp[n];
}
```

## Нэмэлт:

Бодолтонд автоматаар бүх оролтыг шалгадаг кодыг багтаав. /Linux дээр ажиллана/

### hasEnding (string, string)

`ending`-ээр өгөгдсөн string байгаа эсэхийг шалгах функц. Энэ нь фолдерт байгаа
бүх файлыг үзээд `.in` файл эсэхийг шалгахад ашиглагдана.

```cpp
bool hasEnding(string fullString, string ending) {
  if (fullString.length() >= ending.length()) {
    return (0 == fullString.compare(fullString.length() - ending.length(), ending.length(), ending));
  }
  else {
    return false;
  }
}
```

### replaceToOut (string, string)

`input_name` string-ийн төгсгөлийн 3-н char-ийг буюу ".in" хэсгийг ".out"
болгож өөрчилж буй функц. Энэ нь бидэнд тест файлуудын оролт болон гаралтыг
харьцуулахад ашиглагдана.

```cpp
string replaceToOut(string input_name) {
  return input_name.replace(input_name.end() - 3, input_name.end(), ".out");
}
```

### checkAnswers()

`dir` хувьсагч дээр заасан хаяг дээрх бүх файлуудыг уншаад, бүх `filename.in`
өргөтгөлтэй файлуудыг оролт гэж үзэх бөгөөд түүний хариуг нь `filename.out`
файлын өгөгдөлтэй тэнцүүлж харна.

Дараах код нь `cin`-ийг шууд `filename` файлаас уншдаг болгоно.

```cpp
ifstream input("filename");
cin.rdbuf(input.rdbuf());
```

```cpp
void checkAnswers() {
  string dir = "/bod12-zoos1/tests";
  if (chdir(dir.c_str()) == -1) {
    perror(dir.c_str());
    return;
  }
  DIR* dirp = opendir(".");
  for (struct dirent* dent; (dent = readdir(dirp)) != NULL; ) {
    string nm = dent->d_name;
    if (nm == "." || nm == "..")
      continue;
    if (hasEnding(nm, ".in")) {
      // redirecting cin to input file
      ifstream input(nm);
      cin.rdbuf(input.rdbuf());

      int n, temp, answer;
      cin >> n;
      InputType coins;
      for (int i = 0; i < 3; i++) {
        cin >> temp;
        coins.push_back(temp);
      }
      // redirecting cin to output file /test answer/
      ifstream test(replaceToOut(nm));
      cin.rdbuf(test.rdbuf());
      cin >> answer;

      // checking answer
      cout << nm << " >> Expected answer: " << answer << " Given answer: " << solve(n, coins) << endl;
    }
  }
  closedir(dirp);
  return;
}
```

Жишээ гаралт:

```
baljinnyam_test02.in >> Expected answer: 211 Given answer: 211
```
