# Бодлого
## _Шатар бодлого_
_Бодлогын анализыг бичсэн: Д.Балжинням_

<img src="https://www.houseofstaunton.com/media/amasty/blog/cache/p/a/1155/560/pawn-structure-in-chess-how-beginners-win.jpg" width=500 height=200/>

`NxN хэмжээтэй шатрын хөлгийн нүд бүр дээр эерэг тоо бүхий энерги оршино. Шатрын хүү хамгийн дээд талын аль ч нүднээс хамаагүй эхлэн хамгийн доод талын нүдэнд очих ёстой, ингэж очихдоо тухайн өөрийн байгаа нүднээсээ нэг нүд доош эсвэл зүүн доош эсвэд баруун доош явж болно, барианд очихдоо хамгийн бага энерги цуглуулах шаардлагатай.`

Хязгаарлалт:
>N <= 1000
>A[i] <= 100


### Бодлогыг бодох аргачлалууд
- _Brute force_
- DP

### Brute force
NxN хэмжээтэй нүднүүдийн боломжит бүх замуудыг олон тухайн зам бүрт энергийг шалгах бөгөөд ажиллаж дууссаны дараагаар хамгийн бага энерги цуглуулсан замыг сонгож авна
#### *Хугацааны анализ*
> Тухайн нүд бүрт 3 боломж байгаа бөгөөд exponential буюу O(3^n) хугацаанд ажиллана. Энэ нь N = 1000 үед 3^1000000 хугацаанд ажиллах бөгөөд бодож амжихгүй болно.


### DP
Тухайн замын нүд бүр дээр очиход цуглуулсан байж болох хамгийн бага энергийн тоог хадгалах замаар хамгийн бага энергийн хэмжээг доод нүдэн дээр ирэхэд мэдэх боломжтой. 
#### *Хугацааны анализ*
> Бүх нүдээр гүйж тоог хадгалах тул O(n^2) хугацаанд ажиллана. 

Тиймээс энэхүү бодлогод Dynamic Programming арга ашиглавал тохиромжтой.

### Бодолт

A хүснэгтэд оролт буюу NxN хүснэгтийн энергийн хэмжээнүүд өгөгдсөн байна гэж үзье. Тэгвэл бидэнд цуглуулж явсан энергээ хадгалах `DP` хүснэгт хэрэг болно.

>DP буюу энерги хадгалах хүснэгт

NxN хэмжээ бүхий хүснэгтийг үүсгэж өгөх бөгөөд энэ хүснэгтэд  хадгалагдах өмнөх нүднүүдийн хамгийн их утгуудыг ашиглан одоогийн байгаа нүдний хамгийн их утгыг тодорхойлъё.

Энэ нь бидний дэд бодлого болох бөгөөд тухайн нүдэн дээр очиоход цуглуулж чадах хамгийн их энерги нь `DP` хүснэгэндэх өмнөх мөрийн утгуудаас шууд хамаарах юм. Үүний кодыг бичвэл дараах байдлаар бичих боломжтой.

```python
dp[i][j] = max(dp[i-1][j], dp[i-1][j-1],dp[i-1][i+1]) + a[i][j]
# Одоогийн нүдэнд зөвхөн өмнө мөрөөс ирэх боломжтой тул тухайн нүдэнд орших
# максыг олох нь өмнө нүдний максаас шууд хамаарна
```

### Хариу
```python
solution = max(dp[n-1])
return solution
```

### Жишээ
Оролт:
5

| 3 | 1 | 2 | 4 | 1 |
| --- | --- | --- | --- | --- |
| 1 | 2 | 1 | 3 | 4 |
| 1 | 2 | 3 | 2 | 1 |
| 2 | 6 | 1 | 3 | 4 |
| 1 | 6 | 2 | 3 | 1 |

### DP
| 3 | 1 | 2 | 4 | 1 |
| --- | --- | --- | --- | --- |
| 4| 5 | 5 | 7 | 8 |
| 6 | 7 | 10 | 10 | 9 |
| 9 | 16 | 11 | 13 |  14 |
| 17 | 22 | 18 | 17 | 15 |

### Гаралт:
#### OUTPUT : 22


