# Бодлого
## _Бомбтой зоос цуглуулагч робот_

<img src="https://cdn-icons-png.flaticon.com/512/3662/3662787.png" width=200 height=200/>

`Зоос болон хаднуудаас бүрдэх NxN нүднүүдээс бүрдэх агуй дотор робот зам хайна. Робот баруун дээд талаас эхлэн зүүн доод тал хүрэх замыг хайх бөгөөд тухайн робот зөвхөн зүүн, доошоо гэх 2 нүүдлээр явах боломжтой. Тухайн роботод нэг бөмбөг ноогдох бөгөөд тухайн бөмбөгөөр дурын 1 хадыг дэлбэлэн зам үүсгэх боломжтой. Зүүн доод буланд очиход хамгийн их цуглуулж болох зоосны хэмжээг ол.`
Хязгаарлалт:
>N <= 1000
>A[i] <= 100
Тухайн нүд -1 утгатай үед хад гэж тооцно.

### Бодлогыг бодох аргачлалууд
- _Brute force_
- _Graph, BFS_
- DP

### Brute force
NxN хэмжээтэй нүднүүдийн боломжит бүх замуудыг олон тухайн зам бүрт хадыг шалгах бөгөөд ажиллаж дууссаны дараагаар хамгийн их зоос цуглуулсан замыг сонгож авна
### *Хугацааны анализ*
> Тухайн нүд бүрт 2 боломж байгаа бөгөөд exponential буюу O(2^n) хугацаанд ажиллана. Энэ нь N = 1000 үед 2^1000000 хугацаанд ажиллах бөгөөд бодож амжихгүй болно.

### Graph, BFS
Тухайн замын нүд бүрийг graph-ийн орой гэж үзэн баруун дээд оройноос эхлэлтэй BFS буюу түвшний хайлтыг хэрэгжүүлэх бөгөөд хадтай үед хэрхэн замаа шийдвэрлэх талаар дахин сайжруулалтуудыг хийх шаардлагатай болно.
### *Хугацааны анализ*
> Хамгийн хурдан байдлаар буюу тухайн робот хад дэлбэлэхгүйгээр сайн зам олох тохиолдолд хамгийн сайндаа n^2 хугацаанд ажиллах бөгөөд нөхцлүүдийг нэмж өгснөөр илүү удаашрах хандлагатай болно.

### DP
Тухайн замын нүд бүр дээр очиход цуглуулсан байж болох хамгийн их зооснуудын тоог хадгалах замаар хамгийн их зоосны хэмжээг зүүн доод нүдэн дээр ирэхэд мэдэх боломжтой. 
### *Хугацааны анализ*
> Бүх нүдээр гүйж тоог хадгалах тул O(n^2) хугацаанд ажиллана. 

Тиймээс энэхүү бодлогод Dynamic Programming арга ашиглавал тохиромжтой.

### Бодолт

A хүснэгтэд оролт буюу NxN хүснэгтийн хад болон зоосны хэмжээнүүд өгөгдсөн байна гэж үзье.
Бид бөмбөгтэй болон бөмбөггүйг илэрхийлэх 2 төлөв хэрэгтэй бөгөөд тус бүрд нь
>dp1 буюу бөмбөгтэй үед цуглуулах
>dp0 буюу бөмбөгөө хэрэглэсэн үед цуглуулах

тус тус NxN хэмжээ бүхий хүснэгтүүдийг үүсгэж өгөх бөгөөд эдгээрт хадгалагдах өмнөх нүднүүдийн хамгийн их утгуудыг ашиглан одоогийн байгаа нүдний хамгийн их утгыг тодорхойлъё.

Энэ нь бидний дэд бодлого болох бөгөөд тухайн 2 төлөвт тус тусад нь оноож өгөх хэрэгтэй болно. 
dp1 хүснэгтэд хадгалагдах хариунууд нь өмнөх бомбгүй бодлоготой адил хариу байх бөгөөд бидний гол бодох зүйл dp0 хүснэгтийн дэд бодлогыг тодорхойлоход оршино.
Нүд бүр дээр:
`dp1[i][j] = max(dp1[i][j - 1], dp1[i + 1][j]) + a[i][j]`

Бөмбөгөө ашигласан гэж үзвэл:
`dp0[i][j] = max(dp1[i][j], dp0[i][j - 1], dp0[i + 1][j]) + (dp1[i][j] == -1 : a[i][j] ? 0)`
нөхцөлүүдийг шалгаж үзэхэд хангалттай.

Тухайн нүд хад байвал дэлбэлж гарах нөхцөлийг бодох тул
`dp1[i][j] = -1;
dp0[i][j] = max(dp1[i][j - 1], dp1[i + 1][j])` болно.

Бид энэхүү дэд бодлогын суурь нөхцөлөө олохын тулд хамгийн эхний мөр болон баганын мэдээллийг нөөцөлж өгөх хэрэгтэй бөгөөд төлөв тус бүр
### Бөмбөгтэй
`dp1[0][0:j - 1] = a[0][0: j - 1]`
`dp1[0: i - 1][n - 1] = a[0: i - 1][n - 1]`
### Бөмбөггүй
`dp0[0][i] = max(dp1[0][i + 1], dp0[0][i + 1]) + a[0][i]`

## Бодлогын хариу
`dp[n - 1][0]`

### Жишээ
Оролт:
| 0 | -1 | 0 | 0 | 0 |
| --- | --- | --- | --- | --- |
| 0 | 0 | 1 | -1 | 0 |
| 1 | 1 | 0 | -1 | -1 |
| 0 | 0 | 0 | 1 | 1 |
| 0 | 0 | 0 | -1 | 1 |

### dp1
| -1 | -1 | 0 | 0 | 0 |
| --- | --- | --- | --- | --- |
| 1 | 1 | 1 | -1 | 0 |
| 3 | 2 | 1 | -1 | -1 |
| 3 | 2 | 1 | -1 | -1 |
| 3 | 2 | 1 | -1 | -1 |

### dp0
| 0 | 0 | 0 | 0 | 0 |
| --- | --- | --- | --- | --- |
| 1 | 1 | 1 | 0 | 0 |
| 3 | 2 | 1 | -1 | 0 |
| 3 | 2 | 1 | -1 | 1 |
| 3 | 2 | 1 | -1 | 2 |

болж 3 шийд болно.


